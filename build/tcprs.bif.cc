// This file was automatically generated by bifcl from /home/jswaro/src/bro-plugins/tcprs/src/tcprs.bif (plugin mode).


#include "tcprs.bif.h"


#line 6 "tcprs.bif"

#include "Plugin.h"

#line 15 "tcprs.bif"
Val* BifFunc::TCPRS::bro_EnableTCPRSAnalyzer(Frame* frame, val_list* BiF_ARGS)
	
#line 16 "tcprs.bif"
{
	if ( BiF_ARGS->length() != 0 )
		{
		reporter->Error("TCPRS::EnableTCPRSAnalyzer() takes exactly 0 argument(s)");
		return 0;
		}

#line 16 "tcprs.bif"

	return new Val(plugin::Bro_TCPRS::EnableTCPRS(), TYPE_BOOL);
	} // end of BifFunc::TCPRS::bro_EnableTCPRSAnalyzer

#line 18 "tcprs.bif"
namespace TCPRS { EventHandlerPtr conn_spurious_dsack;  }
void BifEvent::TCPRS::generate_conn_spurious_dsack(analyzer::Analyzer* analyzer, Connection* c, double timestamp, bro_uint_t seq, int is_orig, double rtt, bro_int_t state, bro_uint_t o_seq, bro_uint_t beg_seq, bro_uint_t end_seq, bro_int_t reason, bro_int_t rtype)
	{
	// Note that it is intentional that here we do not
	// check if ::TCPRS::conn_spurious_dsack is NULL, which should happen *before*
	// BifEvent::TCPRS::generate_conn_spurious_dsack is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(timestamp, TYPE_TIME));
	vl->append(new Val(seq, TYPE_COUNT));
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(rtt, TYPE_DOUBLE));
	vl->append(new Val(state, TYPE_INT));
	vl->append(new Val(o_seq, TYPE_COUNT));
	vl->append(new Val(beg_seq, TYPE_COUNT));
	vl->append(new Val(end_seq, TYPE_COUNT));
	vl->append(new Val(reason, TYPE_INT));
	vl->append(new Val(rtype, TYPE_INT));

	mgr.QueueEvent(::TCPRS::conn_spurious_dsack, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
namespace TCPRS { EventHandlerPtr conn_rexmit;  }
void BifEvent::TCPRS::generate_conn_rexmit(analyzer::Analyzer* analyzer, Connection* c, double timestamp, bro_uint_t seq, int is_orig, double rtt, bro_int_t state, bro_uint_t o_seq, bro_uint_t beg_seq, bro_uint_t end_seq, bro_int_t reason, bro_int_t rtype, double confidence, bro_int_t flags)
	{
	// Note that it is intentional that here we do not
	// check if ::TCPRS::conn_rexmit is NULL, which should happen *before*
	// BifEvent::TCPRS::generate_conn_rexmit is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(timestamp, TYPE_TIME));
	vl->append(new Val(seq, TYPE_COUNT));
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(rtt, TYPE_DOUBLE));
	vl->append(new Val(state, TYPE_INT));
	vl->append(new Val(o_seq, TYPE_COUNT));
	vl->append(new Val(beg_seq, TYPE_COUNT));
	vl->append(new Val(end_seq, TYPE_COUNT));
	vl->append(new Val(reason, TYPE_INT));
	vl->append(new Val(rtype, TYPE_INT));
	vl->append(new Val(confidence, TYPE_DOUBLE));
	vl->append(new Val(flags, TYPE_INT));

	mgr.QueueEvent(::TCPRS::conn_rexmit, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
namespace TCPRS { EventHandlerPtr conn_rtx_summary;  }
void BifEvent::TCPRS::generate_conn_rtx_summary(analyzer::Analyzer* analyzer, Connection* c, double timestamp, Val* stats, bro_uint_t spurious)
	{
	// Note that it is intentional that here we do not
	// check if ::TCPRS::conn_rtx_summary is NULL, which should happen *before*
	// BifEvent::TCPRS::generate_conn_rtx_summary is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(timestamp, TYPE_TIME));
	vl->append(stats);
	vl->append(new Val(spurious, TYPE_COUNT));

	mgr.QueueEvent(::TCPRS::conn_rtx_summary, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
namespace TCPRS { EventHandlerPtr conn_rtx_types;  }
void BifEvent::TCPRS::generate_conn_rtx_types(analyzer::Analyzer* analyzer, Connection* c, double timestamp, bro_int_t rto, bro_int_t fastrtx, bro_int_t retrans, int isdead)
	{
	// Note that it is intentional that here we do not
	// check if ::TCPRS::conn_rtx_types is NULL, which should happen *before*
	// BifEvent::TCPRS::generate_conn_rtx_types is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(timestamp, TYPE_TIME));
	vl->append(new Val(rto, TYPE_INT));
	vl->append(new Val(fastrtx, TYPE_INT));
	vl->append(new Val(retrans, TYPE_INT));
	vl->append(new Val(isdead, TYPE_BOOL));

	mgr.QueueEvent(::TCPRS::conn_rtx_types, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
namespace TCPRS { EventHandlerPtr tcp_dup_ack;  }
void BifEvent::TCPRS::generate_tcp_dup_ack(analyzer::Analyzer* analyzer, Connection* c, double timestamp, bro_uint_t seq, bro_int_t num_rtx, int is_orig)
	{
	// Note that it is intentional that here we do not
	// check if ::TCPRS::tcp_dup_ack is NULL, which should happen *before*
	// BifEvent::TCPRS::generate_tcp_dup_ack is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(timestamp, TYPE_TIME));
	vl->append(new Val(seq, TYPE_COUNT));
	vl->append(new Val(num_rtx, TYPE_INT));
	vl->append(new Val(is_orig, TYPE_BOOL));

	mgr.QueueEvent(::TCPRS::tcp_dup_ack, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
namespace TCPRS { EventHandlerPtr conn_state_change;  }
void BifEvent::TCPRS::generate_conn_state_change(analyzer::Analyzer* analyzer, Connection* c, double timestamp, bro_int_t prev, bro_int_t current, int is_orig)
	{
	// Note that it is intentional that here we do not
	// check if ::TCPRS::conn_state_change is NULL, which should happen *before*
	// BifEvent::TCPRS::generate_conn_state_change is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(timestamp, TYPE_TIME));
	vl->append(new Val(prev, TYPE_INT));
	vl->append(new Val(current, TYPE_INT));
	vl->append(new Val(is_orig, TYPE_BOOL));

	mgr.QueueEvent(::TCPRS::conn_state_change, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
namespace TCPRS { EventHandlerPtr conn_dead_event;  }
void BifEvent::TCPRS::generate_conn_dead_event(analyzer::Analyzer* analyzer, Connection* c, double timestamp, double duration, bro_int_t state, int is_orig)
	{
	// Note that it is intentional that here we do not
	// check if ::TCPRS::conn_dead_event is NULL, which should happen *before*
	// BifEvent::TCPRS::generate_conn_dead_event is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(timestamp, TYPE_TIME));
	vl->append(new Val(duration, TYPE_DOUBLE));
	vl->append(new Val(state, TYPE_INT));
	vl->append(new Val(is_orig, TYPE_BOOL));

	mgr.QueueEvent(::TCPRS::conn_dead_event, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
namespace TCPRS { EventHandlerPtr conn_ooo_summary;  }
void BifEvent::TCPRS::generate_conn_ooo_summary(analyzer::Analyzer* analyzer, Connection* c, double timestamp, bro_int_t orig, bro_int_t resp, bro_int_t total)
	{
	// Note that it is intentional that here we do not
	// check if ::TCPRS::conn_ooo_summary is NULL, which should happen *before*
	// BifEvent::TCPRS::generate_conn_ooo_summary is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(timestamp, TYPE_TIME));
	vl->append(new Val(orig, TYPE_INT));
	vl->append(new Val(resp, TYPE_INT));
	vl->append(new Val(total, TYPE_INT));

	mgr.QueueEvent(::TCPRS::conn_ooo_summary, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
namespace TCPRS { EventHandlerPtr conn_ooo_event;  }
void BifEvent::TCPRS::generate_conn_ooo_event(analyzer::Analyzer* analyzer, Connection* c, double timestamp, int is_orig, bro_uint_t seq, double gap, double rtt, bro_int_t num_seq, bro_uint_t o_seq, bro_uint_t beg_seq, bro_uint_t end_seq)
	{
	// Note that it is intentional that here we do not
	// check if ::TCPRS::conn_ooo_event is NULL, which should happen *before*
	// BifEvent::TCPRS::generate_conn_ooo_event is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(timestamp, TYPE_TIME));
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(seq, TYPE_COUNT));
	vl->append(new Val(gap, TYPE_DOUBLE));
	vl->append(new Val(rtt, TYPE_DOUBLE));
	vl->append(new Val(num_seq, TYPE_INT));
	vl->append(new Val(o_seq, TYPE_COUNT));
	vl->append(new Val(beg_seq, TYPE_COUNT));
	vl->append(new Val(end_seq, TYPE_COUNT));

	mgr.QueueEvent(::TCPRS::conn_ooo_event, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
namespace TCPRS { EventHandlerPtr conn_ambi_order;  }
void BifEvent::TCPRS::generate_conn_ambi_order(analyzer::Analyzer* analyzer, Connection* c, double timestamp, int is_orig, bro_uint_t seq, double gap, bro_int_t num_seq, bro_uint_t o_seq, bro_uint_t beg_seq, bro_uint_t end_seq)
	{
	// Note that it is intentional that here we do not
	// check if ::TCPRS::conn_ambi_order is NULL, which should happen *before*
	// BifEvent::TCPRS::generate_conn_ambi_order is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(timestamp, TYPE_TIME));
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(seq, TYPE_COUNT));
	vl->append(new Val(gap, TYPE_DOUBLE));
	vl->append(new Val(num_seq, TYPE_INT));
	vl->append(new Val(o_seq, TYPE_COUNT));
	vl->append(new Val(beg_seq, TYPE_COUNT));
	vl->append(new Val(end_seq, TYPE_COUNT));

	mgr.QueueEvent(::TCPRS::conn_ambi_order, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
namespace TCPRS { EventHandlerPtr conn_config;  }
void BifEvent::TCPRS::generate_conn_config(analyzer::Analyzer* analyzer, Connection* c, double timestamp, int ts, int bad_conn, int sack, int o_sack_offer, int r_sack_offer)
	{
	// Note that it is intentional that here we do not
	// check if ::TCPRS::conn_config is NULL, which should happen *before*
	// BifEvent::TCPRS::generate_conn_config is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(timestamp, TYPE_TIME));
	vl->append(new Val(ts, TYPE_BOOL));
	vl->append(new Val(bad_conn, TYPE_BOOL));
	vl->append(new Val(sack, TYPE_BOOL));
	vl->append(new Val(o_sack_offer, TYPE_BOOL));
	vl->append(new Val(r_sack_offer, TYPE_BOOL));

	mgr.QueueEvent(::TCPRS::conn_config, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
namespace TCPRS { EventHandlerPtr conn_rtt_estimate;  }
void BifEvent::TCPRS::generate_conn_rtt_estimate(analyzer::Analyzer* analyzer, Connection* c, double timestamp, double rtt, double c_rtt, double s_rtt)
	{
	// Note that it is intentional that here we do not
	// check if ::TCPRS::conn_rtt_estimate is NULL, which should happen *before*
	// BifEvent::TCPRS::generate_conn_rtt_estimate is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(timestamp, TYPE_TIME));
	vl->append(new Val(rtt, TYPE_DOUBLE));
	vl->append(new Val(c_rtt, TYPE_DOUBLE));
	vl->append(new Val(s_rtt, TYPE_DOUBLE));

	mgr.QueueEvent(::TCPRS::conn_rtt_estimate, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
namespace TCPRS { EventHandlerPtr conn_limited_transmit;  }
void BifEvent::TCPRS::generate_conn_limited_transmit(analyzer::Analyzer* analyzer, Connection* c, double timestamp, bro_uint_t seq, int is_orig, double rtt, bro_int_t state, bro_uint_t o_seq, bro_uint_t beg_seq, bro_uint_t end_seq)
	{
	// Note that it is intentional that here we do not
	// check if ::TCPRS::conn_limited_transmit is NULL, which should happen *before*
	// BifEvent::TCPRS::generate_conn_limited_transmit is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(timestamp, TYPE_TIME));
	vl->append(new Val(seq, TYPE_COUNT));
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(rtt, TYPE_DOUBLE));
	vl->append(new Val(state, TYPE_INT));
	vl->append(new Val(o_seq, TYPE_COUNT));
	vl->append(new Val(beg_seq, TYPE_COUNT));
	vl->append(new Val(end_seq, TYPE_COUNT));

	mgr.QueueEvent(::TCPRS::conn_limited_transmit, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
namespace TCPRS { EventHandlerPtr conn_fast_recovery;  }
void BifEvent::TCPRS::generate_conn_fast_recovery(analyzer::Analyzer* analyzer, Connection* c, double timestamp, bro_uint_t seq, int is_orig, double rtt, bro_int_t state, bro_uint_t o_seq, bro_uint_t beg_seq, bro_uint_t end_seq)
	{
	// Note that it is intentional that here we do not
	// check if ::TCPRS::conn_fast_recovery is NULL, which should happen *before*
	// BifEvent::TCPRS::generate_conn_fast_recovery is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(timestamp, TYPE_TIME));
	vl->append(new Val(seq, TYPE_COUNT));
	vl->append(new Val(is_orig, TYPE_BOOL));
	vl->append(new Val(rtt, TYPE_DOUBLE));
	vl->append(new Val(state, TYPE_INT));
	vl->append(new Val(o_seq, TYPE_COUNT));
	vl->append(new Val(beg_seq, TYPE_COUNT));
	vl->append(new Val(end_seq, TYPE_COUNT));

	mgr.QueueEvent(::TCPRS::conn_fast_recovery, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
namespace TCPRS { EventHandlerPtr conn_initial_rtt;  }
void BifEvent::TCPRS::generate_conn_initial_rtt(analyzer::Analyzer* analyzer, Connection* c, double timestamp, double rtt, int is_orig)
	{
	// Note that it is intentional that here we do not
	// check if ::TCPRS::conn_initial_rtt is NULL, which should happen *before*
	// BifEvent::TCPRS::generate_conn_initial_rtt is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(timestamp, TYPE_TIME));
	vl->append(new Val(rtt, TYPE_DOUBLE));
	vl->append(new Val(is_orig, TYPE_BOOL));

	mgr.QueueEvent(::TCPRS::conn_initial_rtt, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
namespace TCPRS { EventHandlerPtr conn_initial_rto;  }
void BifEvent::TCPRS::generate_conn_initial_rto(analyzer::Analyzer* analyzer, Connection* c, double timestamp, double rto, int is_orig)
	{
	// Note that it is intentional that here we do not
	// check if ::TCPRS::conn_initial_rto is NULL, which should happen *before*
	// BifEvent::TCPRS::generate_conn_initial_rto is called to avoid unnecessary Val
	// allocation.

	val_list* vl = new val_list;

	vl->append(c->BuildConnVal());
	vl->append(new Val(timestamp, TYPE_TIME));
	vl->append(new Val(rto, TYPE_DOUBLE));
	vl->append(new Val(is_orig, TYPE_BOOL));

	mgr.QueueEvent(::TCPRS::conn_initial_rto, vl, SOURCE_LOCAL, analyzer->GetID(), timer_mgr, c);
	} // event generation
